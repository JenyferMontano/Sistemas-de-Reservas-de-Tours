// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tour.sql

package dto

import (
	"context"
	"database/sql"
)

const createTour = `-- name: CreateTour :execresult
INSERT INTO reservas.Tour (idTour, nombre, descripcion, tipo, disponibilidad, precioBase, ubicacion)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateTourParams struct {
	Idtour         int32  `json:"idtour"`
	Nombre         string `json:"nombre"`
	Descripcion    string `json:"descripcion"`
	Tipo           string `json:"tipo"`
	Disponibilidad int8   `json:"disponibilidad"`
	Preciobase     string `json:"preciobase"`
	Ubicacion      string `json:"ubicacion"`
}

func (q *Queries) CreateTour(ctx context.Context, arg CreateTourParams) (sql.Result, error) {
	return q.exec(ctx, q.createTourStmt, createTour,
		arg.Idtour,
		arg.Nombre,
		arg.Descripcion,
		arg.Tipo,
		arg.Disponibilidad,
		arg.Preciobase,
		arg.Ubicacion,
	)
}

const deleteTour = `-- name: DeleteTour :exec
DELETE FROM reservas.Tour WHERE idTour = ?
`

func (q *Queries) DeleteTour(ctx context.Context, idtour int32) error {
	_, err := q.exec(ctx, q.deleteTourStmt, deleteTour, idtour)
	return err
}

const getAllTours = `-- name: GetAllTours :many
SELECT idtour, nombre, descripcion, tipo, disponibilidad, preciobase, ubicacion FROM reservas.Tour
`

func (q *Queries) GetAllTours(ctx context.Context) ([]ReservasTour, error) {
	rows, err := q.query(ctx, q.getAllToursStmt, getAllTours)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReservasTour
	for rows.Next() {
		var i ReservasTour
		if err := rows.Scan(
			&i.Idtour,
			&i.Nombre,
			&i.Descripcion,
			&i.Tipo,
			&i.Disponibilidad,
			&i.Preciobase,
			&i.Ubicacion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTourById = `-- name: GetTourById :one
SELECT idtour, nombre, descripcion, tipo, disponibilidad, preciobase, ubicacion FROM reservas.Tour WHERE idTour = ? LIMIT 1
`

func (q *Queries) GetTourById(ctx context.Context, idtour int32) (ReservasTour, error) {
	row := q.queryRow(ctx, q.getTourByIdStmt, getTourById, idtour)
	var i ReservasTour
	err := row.Scan(
		&i.Idtour,
		&i.Nombre,
		&i.Descripcion,
		&i.Tipo,
		&i.Disponibilidad,
		&i.Preciobase,
		&i.Ubicacion,
	)
	return i, err
}

const getToursByTipo = `-- name: GetToursByTipo :many
SELECT idtour, nombre, descripcion, tipo, disponibilidad, preciobase, ubicacion FROM reservas.Tour WHERE tipo = ?
`

func (q *Queries) GetToursByTipo(ctx context.Context, tipo string) ([]ReservasTour, error) {
	rows, err := q.query(ctx, q.getToursByTipoStmt, getToursByTipo, tipo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReservasTour
	for rows.Next() {
		var i ReservasTour
		if err := rows.Scan(
			&i.Idtour,
			&i.Nombre,
			&i.Descripcion,
			&i.Tipo,
			&i.Disponibilidad,
			&i.Preciobase,
			&i.Ubicacion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTour = `-- name: UpdateTour :exec
UPDATE reservas.Tour
SET nombre = ?, descripcion = ?, tipo = ?, disponibilidad = ?, precioBase = ?, ubicacion = ?
WHERE idTour = ?
`

type UpdateTourParams struct {
	Nombre         string `json:"nombre"`
	Descripcion    string `json:"descripcion"`
	Tipo           string `json:"tipo"`
	Disponibilidad int8   `json:"disponibilidad"`
	Preciobase     string `json:"preciobase"`
	Ubicacion      string `json:"ubicacion"`
	Idtour         int32  `json:"idtour"`
}

func (q *Queries) UpdateTour(ctx context.Context, arg UpdateTourParams) error {
	_, err := q.exec(ctx, q.updateTourStmt, updateTour,
		arg.Nombre,
		arg.Descripcion,
		arg.Tipo,
		arg.Disponibilidad,
		arg.Preciobase,
		arg.Ubicacion,
		arg.Idtour,
	)
	return err
}
