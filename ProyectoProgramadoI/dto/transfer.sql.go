// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: transfer.sql

package dto

import (
	"context"
	"database/sql"
)

const createTransfer = `-- name: CreateTransfer :execresult
INSERT INTO reservas.Transfer (idTransfer, tipo, capacidad)
VALUES (?, ?, ?)
`

type CreateTransferParams struct {
	Idtransfer int32  `json:"idtransfer"`
	Tipo       string `json:"tipo"`
	Capacidad  int32  `json:"capacidad"`
}

func (q *Queries) CreateTransfer(ctx context.Context, arg CreateTransferParams) (sql.Result, error) {
	return q.exec(ctx, q.createTransferStmt, createTransfer, arg.Idtransfer, arg.Tipo, arg.Capacidad)
}

const deleteTransfer = `-- name: DeleteTransfer :exec
DELETE FROM reservas.Transfer WHERE idTransfer = ?
`

func (q *Queries) DeleteTransfer(ctx context.Context, idtransfer int32) error {
	_, err := q.exec(ctx, q.deleteTransferStmt, deleteTransfer, idtransfer)
	return err
}

const getAllTransfers = `-- name: GetAllTransfers :many
SELECT idtransfer, tipo, capacidad FROM reservas.Transfer
`

func (q *Queries) GetAllTransfers(ctx context.Context) ([]ReservasTransfer, error) {
	rows, err := q.query(ctx, q.getAllTransfersStmt, getAllTransfers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReservasTransfer
	for rows.Next() {
		var i ReservasTransfer
		if err := rows.Scan(&i.Idtransfer, &i.Tipo, &i.Capacidad); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransferById = `-- name: GetTransferById :one
SELECT idtransfer, tipo, capacidad FROM reservas.Transfer WHERE idTransfer = ? LIMIT 1
`

func (q *Queries) GetTransferById(ctx context.Context, idtransfer int32) (ReservasTransfer, error) {
	row := q.queryRow(ctx, q.getTransferByIdStmt, getTransferById, idtransfer)
	var i ReservasTransfer
	err := row.Scan(&i.Idtransfer, &i.Tipo, &i.Capacidad)
	return i, err
}

const updateTransfer = `-- name: UpdateTransfer :exec
UPDATE reservas.Transfer
SET tipo = ?, capacidad = ?
WHERE idTransfer = ?
`

type UpdateTransferParams struct {
	Tipo       string `json:"tipo"`
	Capacidad  int32  `json:"capacidad"`
	Idtransfer int32  `json:"idtransfer"`
}

func (q *Queries) UpdateTransfer(ctx context.Context, arg UpdateTransferParams) error {
	_, err := q.exec(ctx, q.updateTransferStmt, updateTransfer, arg.Tipo, arg.Capacidad, arg.Idtransfer)
	return err
}
