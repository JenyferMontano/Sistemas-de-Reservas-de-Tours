// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: usuario.sql

package dto

import (
	"context"
	"database/sql"
)

const createUsuario = `-- name: CreateUsuario :execresult
INSERT INTO reservas.Usuario (userName, password, rol, idPersona)
VALUES (?, ?, ?, ?)
`

type CreateUsuarioParams struct {
	Username  string `json:"username"`
	Password  string `json:"password"`
	Rol       string `json:"rol"`
	Idpersona int32  `json:"idpersona"`
}

func (q *Queries) CreateUsuario(ctx context.Context, arg CreateUsuarioParams) (sql.Result, error) {
	return q.exec(ctx, q.createUsuarioStmt, createUsuario,
		arg.Username,
		arg.Password,
		arg.Rol,
		arg.Idpersona,
	)
}

const deleteUsuario = `-- name: DeleteUsuario :exec
DELETE FROM reservas.Usuario
WHERE userName = ?
`

func (q *Queries) DeleteUsuario(ctx context.Context, username string) error {
	_, err := q.exec(ctx, q.deleteUsuarioStmt, deleteUsuario, username)
	return err
}

const getAllUsuarios = `-- name: GetAllUsuarios :many
SELECT userName, rol, idPersona
FROM reservas.Usuario
`

type GetAllUsuariosRow struct {
	Username  string `json:"username"`
	Rol       string `json:"rol"`
	Idpersona int32  `json:"idpersona"`
}

func (q *Queries) GetAllUsuarios(ctx context.Context) ([]GetAllUsuariosRow, error) {
	rows, err := q.query(ctx, q.getAllUsuariosStmt, getAllUsuarios)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsuariosRow
	for rows.Next() {
		var i GetAllUsuariosRow
		if err := rows.Scan(&i.Username, &i.Rol, &i.Idpersona); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCorreoByUserName = `-- name: GetCorreoByUserName :one
SELECT p.correo
FROM reservas.Usuario u
JOIN reservas.Persona p ON u.idPersona = p.idPersona
WHERE u.userName = ?
`

func (q *Queries) GetCorreoByUserName(ctx context.Context, username string) (string, error) {
	row := q.queryRow(ctx, q.getCorreoByUserNameStmt, getCorreoByUserName, username)
	var correo string
	err := row.Scan(&correo)
	return correo, err
}

const getUsuarioByCorreo = `-- name: GetUsuarioByCorreo :one
SELECT u.userName, u.password, u.rol, u.idPersona
FROM reservas.Usuario u
JOIN reservas.Persona p ON u.idPersona = p.idPersona
WHERE p.correo = ?
`

func (q *Queries) GetUsuarioByCorreo(ctx context.Context, correo string) (ReservasUsuario, error) {
	row := q.queryRow(ctx, q.getUsuarioByCorreoStmt, getUsuarioByCorreo, correo)
	var i ReservasUsuario
	err := row.Scan(
		&i.Username,
		&i.Password,
		&i.Rol,
		&i.Idpersona,
	)
	return i, err
}

const getUsuarioByUserName = `-- name: GetUsuarioByUserName :one
SELECT userName, password, rol, idPersona
FROM reservas.Usuario
WHERE userName = ?
`

func (q *Queries) GetUsuarioByUserName(ctx context.Context, username string) (ReservasUsuario, error) {
	row := q.queryRow(ctx, q.getUsuarioByUserNameStmt, getUsuarioByUserName, username)
	var i ReservasUsuario
	err := row.Scan(
		&i.Username,
		&i.Password,
		&i.Rol,
		&i.Idpersona,
	)
	return i, err
}

const updateUsuario = `-- name: UpdateUsuario :exec
UPDATE reservas.Usuario
SET password = ?
WHERE userName = ?
`

type UpdateUsuarioParams struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

func (q *Queries) UpdateUsuario(ctx context.Context, arg UpdateUsuarioParams) error {
	_, err := q.exec(ctx, q.updateUsuarioStmt, updateUsuario, arg.Password, arg.Username)
	return err
}

const usuarioExiste = `-- name: UsuarioExiste :one
SELECT COUNT(*) as count
FROM reservas.Usuario
WHERE userName = ?
`

func (q *Queries) UsuarioExiste(ctx context.Context, username string) (int64, error) {
	row := q.queryRow(ctx, q.usuarioExisteStmt, usuarioExiste, username)
	var count int64
	err := row.Scan(&count)
	return count, err
}
